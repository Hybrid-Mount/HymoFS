diff -ruN src_origin_with_susfs/fs/hymofs.c src_modified_with_susfs/fs/hymofs.c
--- src_origin_with_susfs/fs/hymofs.c	1970-01-01 08:00:00.000000000 +0800
+++ src_modified_with_susfs/fs/hymofs.c	2025-12-12 13:47:35.806907713 +0800
@@ -0,0 +1,686 @@
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/file.h>
+#include <linux/fdtable.h>
+#include <linux/fsnotify.h>
+#include <linux/module.h>
+#include <linux/tty.h>
+#include <linux/namei.h>
+#include <linux/backing-dev.h>
+#include <linux/capability.h>
+#include <linux/securebits.h>
+#include <linux/security.h>
+#include <linux/mount.h>
+#include <linux/fcntl.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/dcache.h>
+#include <linux/path.h>
+#include <linux/hashtable.h>
+#include <linux/init.h>
+#include <linux/time.h>
+#include <linux/dirent.h>
+
+#include "hymofs.h"
+
+#ifdef CONFIG_HYMOFS
+
+/* HymoFS God Mode - Advanced Path Manipulation */
+#define HYMO_HASH_BITS 10
+
+struct hymo_entry {
+    char *src;
+    char *target;
+    unsigned char type;
+    struct hlist_node node;
+};
+struct hymo_hide_entry {
+    char *path;
+    struct hlist_node node;
+};
+
+struct hymo_inject_entry {
+    char *dir;
+    struct hlist_node node;
+};
+
+static DEFINE_HASHTABLE(hymo_paths, HYMO_HASH_BITS);
+static DEFINE_HASHTABLE(hymo_hide_paths, HYMO_HASH_BITS);
+static DEFINE_HASHTABLE(hymo_inject_dirs, HYMO_HASH_BITS);
+static DEFINE_SPINLOCK(hymo_lock);
+atomic_t hymo_version = ATOMIC_INIT(0);
+EXPORT_SYMBOL(hymo_version);
+
+static void hymo_cleanup(void) {
+    struct hymo_entry *entry;
+    struct hymo_hide_entry *hide_entry;
+    struct hymo_inject_entry *inject_entry;
+    struct hlist_node *tmp;
+    int bkt;
+    hash_for_each_safe(hymo_paths, bkt, tmp, entry, node) {
+        hash_del(&entry->node);
+        kfree(entry->src);
+        kfree(entry->target);
+        kfree(entry);
+    }
+    hash_for_each_safe(hymo_hide_paths, bkt, tmp, hide_entry, node) {
+        hash_del(&hide_entry->node);
+        kfree(hide_entry->path);
+        kfree(hide_entry);
+    }
+    hash_for_each_safe(hymo_inject_dirs, bkt, tmp, inject_entry, node) {
+        hash_del(&inject_entry->node);
+        kfree(inject_entry->dir);
+        kfree(inject_entry);
+    }
+}
+
+static ssize_t hymo_ctl_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos) {
+    char *kbuf, *orig_kbuf, *cmd, *arg1, *arg2, *arg3;
+    struct hymo_entry *entry;
+    struct hymo_hide_entry *hide_entry;
+    struct hymo_inject_entry *inject_entry;
+    u32 hash;
+    unsigned long flags;
+    bool found = false;
+    int bkt;
+    struct hlist_node *tmp;
+
+    if (count == 0 || count > PAGE_SIZE) return -EINVAL;
+    orig_kbuf = kmalloc(count + 1, GFP_KERNEL);
+    if (!orig_kbuf) return -ENOMEM;
+    if (copy_from_user(orig_kbuf, buf, count)) {
+        kfree(orig_kbuf);
+        return -EFAULT;
+    }
+    orig_kbuf[count] = 0;
+    if (count > 0 && orig_kbuf[count - 1] == '\n') orig_kbuf[count - 1] = 0;
+
+    kbuf = orig_kbuf;
+    cmd = strsep(&kbuf, " ");
+    
+    if (!cmd) {
+        kfree(orig_kbuf);
+        return -EINVAL;
+    }
+
+    if (strcmp(cmd, "add") == 0) {
+        arg1 = strsep(&kbuf, " "); // src
+        arg2 = strsep(&kbuf, " "); // target
+        arg3 = strsep(&kbuf, " "); // type (optional)
+        if (!arg1 || !arg2) {
+            kfree(orig_kbuf);
+            return -EINVAL;
+        }
+        hash = full_name_hash(NULL, arg1, strlen(arg1));
+        spin_lock_irqsave(&hymo_lock, flags);
+        hash_for_each_possible(hymo_paths, entry, node, hash) {
+            if (strcmp(entry->src, arg1) == 0) {
+                kfree(entry->target);
+                entry->target = kstrdup(arg2, GFP_ATOMIC);
+                if (arg3) kstrtou8(arg3, 10, &entry->type);
+                else entry->type = 0;
+                found = true;
+                break;
+            }
+        }
+        if (!found) {
+            entry = kmalloc(sizeof(*entry), GFP_ATOMIC);
+            if (entry) {
+                entry->src = kstrdup(arg1, GFP_ATOMIC);
+                entry->target = kstrdup(arg2, GFP_ATOMIC);
+                if (arg3) kstrtou8(arg3, 10, &entry->type);
+                else entry->type = 0;
+                if (entry->src && entry->target)
+                    hash_add(hymo_paths, &entry->node, hash);
+                else {
+                    kfree(entry->src);
+                    kfree(entry->target);
+                    kfree(entry);
+                }
+            }
+        }
+        atomic_inc(&hymo_version);
+        spin_unlock_irqrestore(&hymo_lock, flags);
+    } else if (strcmp(cmd, "hide") == 0) {
+        arg1 = strsep(&kbuf, " ");
+        if (!arg1) {
+            kfree(orig_kbuf);
+            return -EINVAL;
+        }
+        hash = full_name_hash(NULL, arg1, strlen(arg1));
+        spin_lock_irqsave(&hymo_lock, flags);
+        hash_for_each_possible(hymo_hide_paths, hide_entry, node, hash) {
+            if (strcmp(hide_entry->path, arg1) == 0) {
+                found = true;
+                break;
+            }
+        }
+        if (!found) {
+            hide_entry = kmalloc(sizeof(*hide_entry), GFP_ATOMIC);
+            if (hide_entry) {
+                hide_entry->path = kstrdup(arg1, GFP_ATOMIC);
+                if (hide_entry->path)
+                    hash_add(hymo_hide_paths, &hide_entry->node, hash);
+                else
+                    kfree(hide_entry);
+            }
+        }
+        atomic_inc(&hymo_version);
+        spin_unlock_irqrestore(&hymo_lock, flags);
+    } else if (strcmp(cmd, "inject") == 0) {
+        arg1 = strsep(&kbuf, " ");
+        if (!arg1) {
+            kfree(orig_kbuf);
+            return -EINVAL;
+        }
+        hash = full_name_hash(NULL, arg1, strlen(arg1));
+        spin_lock_irqsave(&hymo_lock, flags);
+        hash_for_each_possible(hymo_inject_dirs, inject_entry, node, hash) {
+            if (strcmp(inject_entry->dir, arg1) == 0) {
+                found = true;
+                break;
+            }
+        }
+        if (!found) {
+            inject_entry = kmalloc(sizeof(*inject_entry), GFP_ATOMIC);
+            if (inject_entry) {
+                inject_entry->dir = kstrdup(arg1, GFP_ATOMIC);
+                if (inject_entry->dir)
+                    hash_add(hymo_inject_dirs, &inject_entry->node, hash);
+                else
+                    kfree(inject_entry);
+            }
+        }
+        atomic_inc(&hymo_version);
+        spin_unlock_irqrestore(&hymo_lock, flags);
+    } else if (strcmp(cmd, "delete") == 0) {
+        arg1 = strsep(&kbuf, " ");
+        if (!arg1) {
+            kfree(orig_kbuf);
+            return -EINVAL;
+        }
+        hash = full_name_hash(NULL, arg1, strlen(arg1));
+        spin_lock_irqsave(&hymo_lock, flags);
+        
+        hash_for_each_possible(hymo_paths, entry, node, hash) {
+            if (strcmp(entry->src, arg1) == 0) {
+                hash_del(&entry->node);
+                kfree(entry->src);
+                kfree(entry->target);
+                kfree(entry);
+                goto out_delete;
+            }
+        }
+        hash_for_each_possible(hymo_hide_paths, hide_entry, node, hash) {
+            if (strcmp(hide_entry->path, arg1) == 0) {
+                hash_del(&hide_entry->node);
+                kfree(hide_entry->path);
+                kfree(hide_entry);
+                goto out_delete;
+            }
+        }
+        hash_for_each_possible(hymo_inject_dirs, inject_entry, node, hash) {
+            if (strcmp(inject_entry->dir, arg1) == 0) {
+                hash_del(&inject_entry->node);
+                kfree(inject_entry->dir);
+                kfree(inject_entry);
+                goto out_delete;
+            }
+        }
+out_delete:
+        atomic_inc(&hymo_version);
+        spin_unlock_irqrestore(&hymo_lock, flags);
+    } else if (strcmp(cmd, "clear") == 0) {
+        spin_lock_irqsave(&hymo_lock, flags);
+        hymo_cleanup();
+        atomic_inc(&hymo_version);
+        spin_unlock_irqrestore(&hymo_lock, flags);
+    }
+
+    kfree(orig_kbuf);
+    return count;
+}
+
+static int hymo_ctl_show(struct seq_file *m, void *v) {
+    struct hymo_entry *entry;
+    struct hymo_hide_entry *hide_entry;
+    struct hymo_inject_entry *inject_entry;
+    int bkt;
+    unsigned long flags;
+
+    seq_printf(m, "HymoFS Protocol: 3\n");
+    seq_printf(m, "HymoFS Config Version: %d\n", atomic_read(&hymo_version));
+
+    spin_lock_irqsave(&hymo_lock, flags);
+    hash_for_each(hymo_paths, bkt, entry, node) {
+        seq_printf(m, "add %s %s %d\n", entry->src, entry->target, entry->type);
+    }
+    hash_for_each(hymo_hide_paths, bkt, hide_entry, node) {
+        seq_printf(m, "hide %s\n", hide_entry->path);
+    }
+    hash_for_each(hymo_inject_dirs, bkt, inject_entry, node) {
+        seq_printf(m, "inject %s\n", inject_entry->dir);
+    }
+    spin_unlock_irqrestore(&hymo_lock, flags);
+    return 0;
+}
+
+static int hymo_ctl_open(struct inode *inode, struct file *file) {
+    return single_open(file, hymo_ctl_show, NULL);
+}
+
+static const struct proc_ops hymo_ctl_ops = {
+    .proc_open = hymo_ctl_open,
+    .proc_read = seq_read,
+    .proc_lseek = seq_lseek,
+    .proc_release = single_release,
+    .proc_write = hymo_ctl_write,
+};
+
+static int __init hymofs_init(void)
+{
+    spin_lock_init(&hymo_lock);
+    hash_init(hymo_paths);
+    hash_init(hymo_hide_paths);
+    hash_init(hymo_inject_dirs);
+    
+    proc_create("hymo_ctl", 0660, NULL, &hymo_ctl_ops);
+    
+    pr_info("HymoFS: initialized (Procfs Mode)\n");
+    return 0;
+}
+fs_initcall(hymofs_init);
+
+/* Returns kstrdup'd target if found, NULL otherwise. Caller must kfree. */
+char *__hymofs_resolve_target(const char *pathname)
+{
+    unsigned long flags;
+    struct hymo_entry *entry;
+    u32 hash;
+    char *target = NULL;
+
+    if (atomic_read(&hymo_version) == 0) return NULL;
+    if (!pathname) return NULL;
+    hash = full_name_hash(NULL, pathname, strlen(pathname));
+
+    spin_lock_irqsave(&hymo_lock, flags);
+    hash_for_each_possible(hymo_paths, entry, node, hash) {
+        if (strcmp(entry->src, pathname) == 0) {
+            target = kstrdup(entry->target, GFP_ATOMIC);
+            break;
+        }
+    }
+    spin_unlock_irqrestore(&hymo_lock, flags);
+    return target;
+}
+EXPORT_SYMBOL(__hymofs_resolve_target);
+
+bool __hymofs_should_hide(const char *pathname)
+{
+    unsigned long flags;
+    struct hymo_hide_entry *entry;
+    u32 hash;
+    bool found = false;
+    if (atomic_read(&hymo_version) == 0) return false;
+    if (!pathname) return false;
+
+    hash = full_name_hash(NULL, pathname, strlen(pathname));
+    spin_lock_irqsave(&hymo_lock, flags);
+    hash_for_each_possible(hymo_hide_paths, entry, node, hash) {
+        if (strcmp(entry->path, pathname) == 0) {
+            found = true;
+            break;
+        }
+    }
+    spin_unlock_irqrestore(&hymo_lock, flags);
+    return found;
+}
+EXPORT_SYMBOL(__hymofs_should_hide);
+
+bool __hymofs_should_spoof_mtime(const char *pathname)
+{
+    unsigned long flags;
+    struct hymo_inject_entry *entry;
+    u32 hash;
+    bool found = false;
+
+    if (atomic_read(&hymo_version) == 0) return false;
+    if (!pathname) return false;
+
+    hash = full_name_hash(NULL, pathname, strlen(pathname));
+
+    spin_lock_irqsave(&hymo_lock, flags);
+    hash_for_each_possible(hymo_inject_dirs, entry, node, hash) {
+        if (strcmp(entry->dir, pathname) == 0) {
+            found = true;
+            break;
+        }
+    }
+    spin_unlock_irqrestore(&hymo_lock, flags);
+    return found;
+}
+EXPORT_SYMBOL(__hymofs_should_spoof_mtime);
+
+static bool __hymofs_should_replace(const char *pathname)
+{
+    unsigned long flags;
+    struct hymo_entry *entry;
+    u32 hash;
+    bool found = false;
+
+    if (atomic_read(&hymo_version) == 0) return false;
+    if (!pathname) return false;
+
+    hash = full_name_hash(NULL, pathname, strlen(pathname));
+
+    spin_lock_irqsave(&hymo_lock, flags);
+    hash_for_each_possible(hymo_paths, entry, node, hash) {
+        if (strcmp(entry->src, pathname) == 0) {
+            found = true;
+            break;
+        }
+    }
+    spin_unlock_irqrestore(&hymo_lock, flags);
+    return found;
+}
+
+int hymofs_populate_injected_list(const char *dir_path, struct dentry *parent, struct list_head *head)
+{
+    unsigned long flags;
+    struct hymo_entry *entry;
+    struct hymo_inject_entry *inject_entry;
+    struct hymo_name_list *item;
+    u32 hash;
+    int bkt;
+    bool should_inject = false;
+    size_t dir_len;
+    if (atomic_read(&hymo_version) == 0) return 0;
+    if (!dir_path) return 0;
+
+    dir_len = strlen(dir_path);
+    hash = full_name_hash(NULL, dir_path, dir_len);
+
+    spin_lock_irqsave(&hymo_lock, flags);
+    
+    hash_for_each_possible(hymo_inject_dirs, inject_entry, node, hash) {
+        if (strcmp(inject_entry->dir, dir_path) == 0) {
+            should_inject = true;
+            break;
+        }
+    }
+    if (should_inject) {
+        hash_for_each(hymo_paths, bkt, entry, node) {
+            if (strncmp(entry->src, dir_path, dir_len) == 0) {
+                char *name = NULL;
+                if (dir_len == 1 && dir_path[0] == '/') {
+                    name = entry->src + 1;
+                } else if (entry->src[dir_len] == '/') {
+                    name = entry->src + dir_len + 1;
+                }
+
+                if (name && *name && strchr(name, '/') == NULL) {
+                    item = kmalloc(sizeof(*item), GFP_ATOMIC);
+                    if (item) {
+                        item->name = kstrdup(name, GFP_ATOMIC);
+                        item->type = entry->type;
+                        if (item->name) list_add(&item->list, head);
+                        else kfree(item);
+                    }
+                }
+            }
+        }
+    }
+
+    spin_unlock_irqrestore(&hymo_lock, flags);
+    return 0;
+}
+EXPORT_SYMBOL(hymofs_populate_injected_list);
+
+struct filename *hymofs_handle_getname(struct filename *result)
+{
+    char *target;
+
+    if (IS_ERR(result)) return result;
+
+    /* HymoFS God Mode Hook */
+    if (hymofs_should_hide(result->name)) {
+        putname(result);
+        /* Return ENOENT directly */
+        return ERR_PTR(-ENOENT);
+    } else {
+        target = hymofs_resolve_target(result->name);
+        if (target) {
+            putname(result);
+            result = getname_kernel(target);
+            kfree(target);
+        }
+    }
+    return result;
+}
+EXPORT_SYMBOL(hymofs_handle_getname);
+
+void __hymofs_prepare_readdir(struct hymo_readdir_context *ctx, struct file *file)
+{
+    ctx->file = file;
+    ctx->path_buf = NULL;
+    ctx->dir_path = NULL;
+    ctx->dir_path_len = 0;
+
+    ctx->path_buf = (char *)__get_free_page(GFP_KERNEL);
+    if (ctx->path_buf && file && file->f_path.dentry) {
+        char *p = d_path(&file->f_path, ctx->path_buf, PAGE_SIZE);
+        if (!IS_ERR(p)) {
+            int len = strlen(p);
+            memmove(ctx->path_buf, p, len + 1);
+            ctx->dir_path = ctx->path_buf;
+            ctx->dir_path_len = len;
+        } else {
+            free_page((unsigned long)ctx->path_buf);
+            ctx->path_buf = NULL;
+        }
+    }
+}
+EXPORT_SYMBOL(__hymofs_prepare_readdir);
+
+void __hymofs_cleanup_readdir(struct hymo_readdir_context *ctx)
+{
+    if (ctx->path_buf) free_page((unsigned long)ctx->path_buf);
+}
+EXPORT_SYMBOL(__hymofs_cleanup_readdir);
+
+bool __hymofs_check_filldir(struct hymo_readdir_context *ctx, const char *name, int namlen)
+{
+    if (ctx->dir_path) {
+        if (ctx->dir_path_len + 1 + namlen < PAGE_SIZE) {
+            char *p = ctx->path_buf + ctx->dir_path_len;
+            if (p > ctx->path_buf && p[-1] != '/') *p++ = '/';
+            memcpy(p, name, namlen);
+            p[namlen] = '\0';
+            if (hymofs_should_hide(ctx->path_buf)) return true;
+            if (__hymofs_should_replace(ctx->path_buf)) return true;
+        }
+    }
+    return false;
+}
+EXPORT_SYMBOL(__hymofs_check_filldir);
+
+struct linux_dirent {
+	unsigned long	d_ino;
+	unsigned long	d_off;
+	unsigned short	d_reclen;
+	char		d_name[];
+};
+
+int hymofs_inject_entries(struct hymo_readdir_context *ctx, void __user **dir_ptr, int *count, loff_t *pos)
+{
+    struct linux_dirent __user *current_dir = *dir_ptr;
+    struct list_head head;
+    struct hymo_name_list *item, *tmp;
+    loff_t current_idx = 0;
+    loff_t start_idx;
+    int injected = 0;
+    int error = 0;
+    int initial_count = *count;
+    bool is_transition = (*pos < HYMO_MAGIC_POS);
+    struct dentry *parent;
+
+    if (!ctx->file) return 0;
+    parent = ctx->file->f_path.dentry;
+
+    if (is_transition) {
+        start_idx = 0;
+    } else {
+        start_idx = *pos - HYMO_MAGIC_POS;
+    }
+
+    INIT_LIST_HEAD(&head);
+    hymofs_populate_injected_list(ctx->dir_path, parent, &head);
+
+    list_for_each_entry_safe(item, tmp, &head, list) {
+        if (current_idx >= start_idx) {
+            int name_len = strlen(item->name);
+            int reclen = ALIGN(offsetof(struct linux_dirent, d_name) + name_len + 2, sizeof(long));
+            if (*count >= reclen) {
+                struct linux_dirent d;
+                d.d_ino = 1;
+                d.d_off = HYMO_MAGIC_POS + current_idx + 1;
+                d.d_reclen = reclen;
+                if (copy_to_user(current_dir, &d, offsetof(struct linux_dirent, d_name)) ||
+                    copy_to_user(current_dir->d_name, item->name, name_len) ||
+                    put_user(0, current_dir->d_name + name_len) ||
+                    put_user(item->type, (char __user *)current_dir + reclen - 1)) {
+                        error = -EFAULT;
+                        break;
+                }
+                current_dir = (struct linux_dirent __user *)((char __user *)current_dir + reclen);
+                *count -= reclen;
+                injected++;
+            } else {
+                break;
+            }
+        }
+        current_idx++;
+        list_del(&item->list);
+        kfree(item->name);
+        kfree(item);
+    }
+    
+    list_for_each_entry_safe(item, tmp, &head, list) {
+        list_del(&item->list);
+        kfree(item->name);
+        kfree(item);
+    }
+
+    if (error == 0) {
+        if (injected > 0) {
+            if (is_transition) {
+                *pos = HYMO_MAGIC_POS + injected;
+            } else {
+                *pos += injected;
+            }
+        }
+        error = initial_count - *count;
+    }
+    
+    *dir_ptr = current_dir;
+    return error;
+}
+EXPORT_SYMBOL(hymofs_inject_entries);
+
+int hymofs_inject_entries64(struct hymo_readdir_context *ctx, void __user **dir_ptr, int *count, loff_t *pos)
+{
+    struct linux_dirent64 __user *current_dir = *dir_ptr;
+    struct list_head head;
+    struct hymo_name_list *item, *tmp;
+    loff_t current_idx = 0;
+    loff_t start_idx;
+    int injected = 0;
+    int error = 0;
+    int initial_count = *count;
+    bool is_transition = (*pos < HYMO_MAGIC_POS);
+    struct dentry *parent;
+
+    if (!ctx->file) return 0;
+    parent = ctx->file->f_path.dentry;
+
+    if (is_transition) {
+        start_idx = 0;
+    } else {
+        start_idx = *pos - HYMO_MAGIC_POS;
+    }
+
+    INIT_LIST_HEAD(&head);
+    hymofs_populate_injected_list(ctx->dir_path, parent, &head);
+
+    list_for_each_entry_safe(item, tmp, &head, list) {
+        if (current_idx >= start_idx) {
+            int name_len = strlen(item->name);
+            int reclen = ALIGN(offsetof(struct linux_dirent64, d_name) + name_len + 1, sizeof(u64));
+            if (*count >= reclen) {
+                struct linux_dirent64 d;
+                d.d_ino = 1;
+                d.d_off = HYMO_MAGIC_POS + current_idx + 1;
+                d.d_reclen = reclen;
+                d.d_type = item->type;
+                if (copy_to_user(current_dir, &d, offsetof(struct linux_dirent64, d_name)) ||
+                    copy_to_user(current_dir->d_name, item->name, name_len) ||
+                    put_user(0, current_dir->d_name + name_len)) {
+                        error = -EFAULT;
+                        break;
+                }
+                current_dir = (struct linux_dirent64 __user *)((char __user *)current_dir + reclen);
+                *count -= reclen;
+                injected++;
+            } else {
+                break;
+            }
+        }
+        current_idx++;
+        list_del(&item->list);
+        kfree(item->name);
+        kfree(item);
+    }
+    
+    list_for_each_entry_safe(item, tmp, &head, list) {
+        list_del(&item->list);
+        kfree(item->name);
+        kfree(item);
+    }
+
+    if (error == 0) {
+        if (injected > 0) {
+            if (is_transition) {
+                *pos = HYMO_MAGIC_POS + injected;
+            } else {
+                *pos += injected;
+            }
+        }
+        error = initial_count - *count;
+    }
+    
+    *dir_ptr = current_dir;
+    return error;
+}
+EXPORT_SYMBOL(hymofs_inject_entries64);
+
+void hymofs_spoof_stat(const struct path *path, struct kstat *stat)
+{
+    char *buf = (char *)__get_free_page(GFP_KERNEL);
+    if (buf && path && path->dentry) {
+        char *p = d_path(path, buf, PAGE_SIZE);
+        if (!IS_ERR(p)) {
+            if (hymofs_should_spoof_mtime(p)) {
+                ktime_get_real_ts64(&stat->mtime);
+                stat->ctime = stat->mtime;
+            }
+        }
+        free_page((unsigned long)buf);
+    }
+}
+EXPORT_SYMBOL(hymofs_spoof_stat);
+
+#endif /* CONFIG_HYMOFS */
diff -ruN src_origin_with_susfs/fs/hymofs.h src_modified_with_susfs/fs/hymofs.h
--- src_origin_with_susfs/fs/hymofs.h	1970-01-01 08:00:00.000000000 +0800
+++ src_modified_with_susfs/fs/hymofs.h	2025-12-12 12:06:41.535428520 +0800
@@ -0,0 +1,96 @@
+#ifndef _LINUX_HYMOFS_H
+#define _LINUX_HYMOFS_H
+
+#include <linux/types.h>
+#include <linux/list.h>
+
+#ifdef CONFIG_HYMOFS
+
+#define HYMO_MAGIC_POS 0x7000000000000000ULL
+
+struct hymo_readdir_context {
+    struct file *file;
+    char *path_buf;
+    char *dir_path;
+    int dir_path_len;
+};
+
+extern atomic_t hymo_version;
+
+void __hymofs_prepare_readdir(struct hymo_readdir_context *ctx, struct file *file);
+void __hymofs_cleanup_readdir(struct hymo_readdir_context *ctx);
+bool __hymofs_check_filldir(struct hymo_readdir_context *ctx, const char *name, int namlen);
+int hymofs_inject_entries(struct hymo_readdir_context *ctx, void __user **dir_ptr, int *count, loff_t *pos);
+int hymofs_inject_entries64(struct hymo_readdir_context *ctx, void __user **dir_ptr, int *count, loff_t *pos);
+void hymofs_spoof_stat(const struct path *path, struct kstat *stat);
+
+struct hymo_name_list {
+    char *name;
+    unsigned char type;
+    struct list_head list;
+};
+
+struct filename;
+struct filename *hymofs_handle_getname(struct filename *result);
+
+char *__hymofs_resolve_target(const char *pathname);
+bool __hymofs_should_hide(const char *pathname);
+bool __hymofs_should_spoof_mtime(const char *pathname);
+int hymofs_populate_injected_list(const char *dir_path, struct dentry *parent, struct list_head *head);
+
+static inline void hymofs_prepare_readdir(struct hymo_readdir_context *ctx, struct file *file)
+{
+    ctx->path_buf = NULL;
+    ctx->file = file;
+    if (atomic_read(&hymo_version) == 0) return;
+    __hymofs_prepare_readdir(ctx, file);
+}
+
+static inline void hymofs_cleanup_readdir(struct hymo_readdir_context *ctx)
+{
+    if (ctx->path_buf) __hymofs_cleanup_readdir(ctx);
+}
+
+static inline bool hymofs_check_filldir(struct hymo_readdir_context *ctx, const char *name, int namlen)
+{
+    if (!ctx->path_buf) return false;
+    return __hymofs_check_filldir(ctx, name, namlen);
+}
+
+static inline char *hymofs_resolve_target(const char *pathname)
+{
+    if (atomic_read(&hymo_version) == 0) return NULL;
+    return __hymofs_resolve_target(pathname);
+}
+
+static inline bool hymofs_should_hide(const char *pathname)
+{
+    if (atomic_read(&hymo_version) == 0) return false;
+    return __hymofs_should_hide(pathname);
+}
+
+static inline bool hymofs_should_spoof_mtime(const char *pathname)
+{
+    if (atomic_read(&hymo_version) == 0) return false;
+    return __hymofs_should_spoof_mtime(pathname);
+}
+
+#else
+
+struct hymo_readdir_context {};
+static inline void hymofs_prepare_readdir(struct hymo_readdir_context *ctx, struct file *file) {}
+static inline void hymofs_cleanup_readdir(struct hymo_readdir_context *ctx) {}
+static inline bool hymofs_check_filldir(struct hymo_readdir_context *ctx, const char *name, int namlen) { return false; }
+static inline int hymofs_inject_entries(struct hymo_readdir_context *ctx, void __user **dir_ptr, int *count, loff_t *pos) { return 0; }
+static inline int hymofs_inject_entries64(struct hymo_readdir_context *ctx, void __user **dir_ptr, int *count, loff_t *pos) { return 0; }
+static inline void hymofs_spoof_stat(const struct path *path, struct kstat *stat) {}
+
+static inline struct filename *hymofs_handle_getname(struct filename *result) { return result; }
+static inline char *hymofs_resolve_target(const char *pathname) { return NULL; }
+static inline bool hymofs_should_hide(const char *pathname) { return false; }
+static inline bool hymofs_should_spoof_mtime(const char *pathname) { return false; }
+static inline int hymofs_populate_injected_list(const char *dir_path, struct dentry *parent, struct list_head *head) { return 0; }
+
+#endif /* CONFIG_HYMOFS */
+
+#endif /* _LINUX_HYMOFS_H */
diff -ruN src_origin_with_susfs/fs/Kconfig src_modified_with_susfs/fs/Kconfig
--- src_origin_with_susfs/fs/Kconfig	2025-12-11 05:57:54.074927137 +0800
+++ src_modified_with_susfs/fs/Kconfig	2025-12-11 05:57:54.069979232 +0800
@@ -405,4 +405,10 @@
 config IO_WQ
 	bool
 
+config HYMOFS
+	bool "HymoFS support"
+	default y
+	help
+	  HymoFS is a kernel-level path manipulation and hiding framework.
+
 endmenu
diff -ruN src_origin_with_susfs/fs/Makefile src_modified_with_susfs/fs/Makefile
--- src_origin_with_susfs/fs/Makefile	2025-12-12 02:01:35.293595985 +0800
+++ src_modified_with_susfs/fs/Makefile	2025-12-12 07:42:31.263192253 +0800
@@ -23,6 +23,7 @@
 		kernel_read_file.o mnt_idmapping.o remap_range.o
 
 obj-$(CONFIG_KSU_SUSFS) += susfs.o
+obj-$(CONFIG_HYMOFS) += hymofs.o
 
 obj-$(CONFIG_BUFFER_HEAD)	+= buffer.o mpage.o
 obj-$(CONFIG_PROC_FS)		+= proc_namespace.o
diff -ruN src_origin_with_susfs/fs/namei.c src_modified_with_susfs/fs/namei.c
--- src_origin_with_susfs/fs/namei.c	2025-12-11 05:57:54.075407183 +0800
+++ src_modified_with_susfs/fs/namei.c	2025-12-12 04:03:39.535007379 +0800
@@ -57,6 +57,10 @@
 extern const struct qstr susfs_fake_qstr_name;
 #endif
 
+#ifdef CONFIG_HYMOFS
+#include "hymofs.h"
+#endif
+
 /* [Feb-1997 T. Schoebel-Theuer]
  * Fundamental changes in the pathname lookup mechanisms (namei)
  * were necessary because of omirr.  The reason is that omirr needs
@@ -138,8 +142,21 @@
 
 #define EMBEDDED_NAME_MAX	(PATH_MAX - offsetof(struct filename, iname))
 
+#ifdef CONFIG_HYMOFS
+struct filename *__original_getname_flags(const char __user *filename, int flags, int *empty);
+
+struct filename *getname_flags(const char __user *filename, int flags, int *empty)
+{
+	struct filename *result = __original_getname_flags(filename, flags, empty);
+	return hymofs_handle_getname(result);
+}
+#endif
 struct filename *
+#ifdef CONFIG_HYMOFS
+__original_getname_flags(const char __user *filename, int flags, int *empty)
+#else
 getname_flags(const char __user *filename, int flags, int *empty)
+#endif
 {
 	struct filename *result;
 	char *kname;
diff -ruN src_origin_with_susfs/fs/readdir.c src_modified_with_susfs/fs/readdir.c
--- src_origin_with_susfs/fs/readdir.c	2025-12-11 05:57:54.075969120 +0800
+++ src_modified_with_susfs/fs/readdir.c	2025-12-12 04:20:54.849133432 +0800
@@ -32,6 +32,11 @@
 extern bool susfs_is_base_dentry_android_data_dir(struct dentry* base);
 extern bool susfs_is_base_dentry_sdcard_dir(struct dentry* base);
 #endif
+
+#ifdef CONFIG_HYMOFS
+#include "hymofs.h"
+#endif
+
 /*
  * Some filesystems were never converted to '->iterate_shared()'
  * and their directory iterators want the inode lock held for
@@ -180,6 +185,9 @@
 
 struct readdir_callback {
 	struct dir_context ctx;
+#ifdef CONFIG_HYMOFS
+	struct hymo_readdir_context hymo;
+#endif
 	struct old_linux_dirent __user * dirent;
 #ifdef CONFIG_KSU_SUSFS_SUS_PATH
 	struct super_block *sb;
@@ -267,6 +275,9 @@
 
 	if (!f.file)
 		return -EBADF;
+#ifdef CONFIG_HYMOFS
+	hymofs_prepare_readdir(&buf.hymo, f.file);
+#endif
 
 #ifdef CONFIG_KSU_SUSFS_SUS_PATH
 	buf.sb = f.file->f_inode->i_sb;
@@ -294,6 +305,9 @@
 	if (buf.result)
 		error = buf.result;
 
+#ifdef CONFIG_HYMOFS
+	hymofs_cleanup_readdir(&buf.hymo);
+#endif
 	fdput_pos(f);
 	return error;
 }
@@ -313,6 +327,9 @@
 
 struct getdents_callback {
 	struct dir_context ctx;
+#ifdef CONFIG_HYMOFS
+	struct hymo_readdir_context hymo;
+#endif
 	struct linux_dirent __user * current_dir;
 #ifdef CONFIG_KSU_SUSFS_SUS_PATH
 	struct super_block *sb;
@@ -335,7 +352,13 @@
 	int reclen = ALIGN(offsetof(struct linux_dirent, d_name) + namlen + 2,
 		sizeof(long));
 	int prev_reclen;
+
+#ifdef CONFIG_HYMOFS
+    if (hymofs_check_filldir(&buf->hymo, name, strlen(name))) return true;
+#endif
+
 #ifdef CONFIG_KSU_SUSFS_SUS_PATH
+
 	struct inode *inode;
 #endif
 
@@ -417,6 +440,20 @@
 	f = fdget_pos(fd);
 	if (!f.file)
 		return -EBADF;
+#ifdef CONFIG_HYMOFS
+	hymofs_prepare_readdir(&buf.hymo, f.file);
+	if (f.file->f_pos >= HYMO_MAGIC_POS) {
+		void __user *dir_ptr = buf.current_dir;
+		int res = hymofs_inject_entries(&buf.hymo, &dir_ptr, &buf.count, &f.file->f_pos);
+		if (res >= 0)
+			error = count - buf.count;
+		else
+			error = res;
+		hymofs_cleanup_readdir(&buf.hymo);
+		fdput_pos(f);
+		return error;
+	}
+#endif
 
 #ifdef CONFIG_KSU_SUSFS_SUS_PATH
 	buf.sb = f.file->f_inode->i_sb;
@@ -452,12 +489,24 @@
 		else
 			error = count - buf.count;
 	}
+#ifdef CONFIG_HYMOFS
+	if (error >= 0) {
+		void __user *dir_ptr = buf.current_dir;
+		int res = hymofs_inject_entries(&buf.hymo, &dir_ptr, &buf.count, &f.file->f_pos);
+		if (res > 0)
+			error = count - buf.count;
+	}
+	hymofs_cleanup_readdir(&buf.hymo);
+#endif
 	fdput_pos(f);
 	return error;
 }
 
 struct getdents_callback64 {
 	struct dir_context ctx;
+#ifdef CONFIG_HYMOFS
+	struct hymo_readdir_context hymo;
+#endif
 	struct linux_dirent64 __user * current_dir;
 #ifdef CONFIG_KSU_SUSFS_SUS_PATH
 	struct super_block *sb;
@@ -479,6 +528,11 @@
 	int reclen = ALIGN(offsetof(struct linux_dirent64, d_name) + namlen + 1,
 		sizeof(u64));
 	int prev_reclen;
+
+#ifdef CONFIG_HYMOFS
+	if (hymofs_check_filldir(&buf->hymo, name, namlen)) return true;
+#endif
+
 #ifdef CONFIG_KSU_SUSFS_SUS_PATH
 	struct inode *inode;
 #endif
@@ -558,6 +612,21 @@
 	if (!f.file)
 		return -EBADF;
 
+#ifdef CONFIG_HYMOFS
+	hymofs_prepare_readdir(&buf.hymo, f.file);
+	if (f.file->f_pos >= HYMO_MAGIC_POS) {
+		void __user *dir_ptr = buf.current_dir;
+		int res = hymofs_inject_entries64(&buf.hymo, &dir_ptr, &buf.count, &f.file->f_pos);
+		if (res >= 0)
+			error = count - buf.count;
+		else
+			error = res;
+		hymofs_cleanup_readdir(&buf.hymo);
+		fdput_pos(f);
+		return error;
+	}
+#endif
+
 #ifdef CONFIG_KSU_SUSFS_SUS_PATH
 	buf.sb = f.file->f_inode->i_sb;
 	inode = f.file->f_path.dentry->d_inode;
@@ -593,6 +662,15 @@
 		else
 			error = count - buf.count;
 	}
+#ifdef CONFIG_HYMOFS
+	if (error >= 0) {
+		void __user *dir_ptr = buf.current_dir;
+		int res = hymofs_inject_entries64(&buf.hymo, &dir_ptr, &buf.count, &f.file->f_pos);
+		if (res > 0)
+			error = count - buf.count;
+	}
+	hymofs_cleanup_readdir(&buf.hymo);
+#endif
 	fdput_pos(f);
 	return error;
 }
@@ -607,6 +685,9 @@
 
 struct compat_readdir_callback {
 	struct dir_context ctx;
+#ifdef CONFIG_HYMOFS
+	struct hymo_readdir_context hymo;
+#endif
 	struct compat_old_linux_dirent __user *dirent;
 #ifdef CONFIG_KSU_SUSFS_SUS_PATH
 	struct super_block *sb;
@@ -696,6 +777,10 @@
 	if (!f.file)
 		return -EBADF;
 
+#ifdef CONFIG_HYMOFS
+	hymofs_prepare_readdir(&buf.hymo, f.file);
+#endif
+
 #ifdef CONFIG_KSU_SUSFS_SUS_PATH
 	buf.sb = f.file->f_inode->i_sb;
 	inode = f.file->f_path.dentry->d_inode;
@@ -722,6 +807,9 @@
 	if (buf.result)
 		error = buf.result;
 
+#ifdef CONFIG_HYMOFS
+	hymofs_cleanup_readdir(&buf.hymo);
+#endif
 	fdput_pos(f);
 	return error;
 }
@@ -735,6 +823,9 @@
 
 struct compat_getdents_callback {
 	struct dir_context ctx;
+#ifdef CONFIG_HYMOFS
+	struct hymo_readdir_context hymo;
+#endif
 	struct compat_linux_dirent __user *current_dir;
 #ifdef CONFIG_KSU_SUSFS_SUS_PATH
 	struct super_block *sb;
@@ -757,6 +848,10 @@
 	int reclen = ALIGN(offsetof(struct compat_linux_dirent, d_name) +
 		namlen + 2, sizeof(compat_long_t));
 	int prev_reclen;
+
+#ifdef CONFIG_HYMOFS
+    if (hymofs_check_filldir(&buf->hymo, name, namlen)) return true;
+#endif
 #ifdef CONFIG_KSU_SUSFS_SUS_PATH
 	struct inode *inode;
 #endif
@@ -838,6 +933,10 @@
 	if (!f.file)
 		return -EBADF;
 
+#ifdef CONFIG_HYMOFS
+	hymofs_prepare_readdir(&buf.hymo, f.file);
+#endif
+
 #ifdef CONFIG_KSU_SUSFS_SUS_PATH
 	buf.sb = f.file->f_inode->i_sb;
 	inode = f.file->f_path.dentry->d_inode;
@@ -872,6 +971,9 @@
 		else
 			error = count - buf.count;
 	}
+#ifdef CONFIG_HYMOFS
+	hymofs_cleanup_readdir(&buf.hymo);
+#endif
 	fdput_pos(f);
 	return error;
 }
diff -ruN src_origin_with_susfs/fs/stat.c src_modified_with_susfs/fs/stat.c
--- src_origin_with_susfs/fs/stat.c	2025-12-11 05:57:54.076204296 +0800
+++ src_modified_with_susfs/fs/stat.c	2025-12-12 04:03:39.529007301 +0800
@@ -30,10 +30,15 @@
 #include "internal.h"
 #include "mount.h"
 
+
 #ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
 extern void susfs_sus_ino_for_generic_fillattr(unsigned long ino, struct kstat *stat);
 #endif
 
+#ifdef CONFIG_HYMOFS
+#include "hymofs.h"
+#endif
+
 /**
  * generic_fillattr - Fill in the basic attributes from the inode struct
  * @idmap:		idmap of the mount the inode was found from
@@ -158,6 +163,9 @@
 					    query_flags | AT_GETATTR_NOSEC);
 
 	generic_fillattr(idmap, request_mask, inode, stat);
+#ifdef CONFIG_HYMOFS
+	hymofs_spoof_stat(path, stat);
+#endif
 	return 0;
 }
 EXPORT_SYMBOL(vfs_getattr_nosec);
